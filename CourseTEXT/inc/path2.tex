\section{ПРИМЕНЕННЫЕ ТЕХНОЛОГИИ}

\subsection{Протокол для создания защищенного соединения SSL/TLS}
Transport Layer Security (TLS) -- протокол безопасности транспортного уровня, преемник ныне устаревшего Secure Sockets Layer (SSL)  -- протокола уровня защищенных сокетов. В настоящее время является наиболее распространенным протоколом безопасности в интернете.

TLS представляет собой криптографический протокол для обеспечения сквозной безопасности связи между двумя организациями с аутентификацией и защитой данных. За счет использования доверенных сертификатов и шифрования обеспечивается конфиденциальность и подлинность передаваемых данных. Протокол реализован на application-уровне, непосредственно над TCP (Transmission Control Protocol), поэтому в нем отсутствует проверка доставки пакета, т.к. она осуществляется на уровне ниже и, следовательно, гарантируется целостность данных.

Действия протокола TLS базируются на принципах:
\begin{enumerate}
	\item Соединение является приватным. В процессе передачи данных они шифруются методами криптографии. Для каждого соединения генерируются уникальные секретные ключи.
	\item Соединение надежно. Сообщение при передаче проходят проверку целостности, используя код проверки подлинность сообщений.
\end{enumerate}

На сегодняшний день актуальными являются протоколы TLSv1.2 и TLSv1.3, опубликованные в 2008 и 2018 году, соответственно. SSL протоколы устарели и не рекомендуются к использованию, SSLv3 был признан устаревшим в 2015 году.
                                                                      
Рассмотрим процесс рукопожатия на актуальных версиях протокола TLS:

Для TLSv1.2 схема рукопожатия представлена на рис. \ref{pix1} и она состоит из шести основных этапов:
\addimg{pix/TLS\_2}{0.7}{Процесс рукопожатия для TLSv1.2}{pix1}
\newpage
\begin{enumerate}
	\item Клиент отправляет серверу сообщение «Client Hello». Это сообщение состоит из криптографической информации, такой как поддерживаемые протоколы и поддерживаемые наборы шифров. Он также состоит из случайного значения или случайной строки байтов.
	\item В ответ на сообщение клиента «Client Hello» сервер отвечает сообщением «Server Hello». Это сообщение включает шифр, выбранный сервером из предложенных клиентом. Сервер также отправляет свой сертификат вместе с идентификатором сеанса и другим случайным значением.
	\item После получения Hello сервера, клиент проверяет подлинность сертификата, отправленного сервером, после завершения проверки он отправляет случайную строку байтов, также называемую ``предварительным секретом'', и шифрует её с использованием открытого ключа сертификата сервера.
	\item Как только сервер получает предварительный главный секрет, клиент и сервер генерируют главный ключ вместе с сеансовыми ключами (эфемерными ключами). Эти сеансовые ключи будут использоваться для симметричного шифрования данных.
	\item Теперь клиент отправляет серверу сообщение «Change Cipher Spec», чтобы сообщить ему, что он собирается переключиться на симметричное шифрование с помощью сеансовых ключей. Наряду с этим он также отправляет сообщение «Клиент готов».
	\item  В ответ на сообщение клиента «Change Cipher Spec» сервер делает то же самое и переключает состояние безопасности на симметричное шифрование. Сервер завершает рукопожатие, отправляя сообщение «сервер готов».
\end{enumerate}
В TLSv1.3 в отличие от v1.2 процесс рукопожатия включает только одну передачу туда и обратно, а не три, что приводит к уменьшению задержки. Также TLSv1.3 уменьшил количество поддерживаемых шифров с 37 до 5.  Схема обмена сообщениями для 3-ей версии показана на рис. \ref{pix1v3}.

Рассмотрим этапы рукопожатия подробнее:
\begin{enumerate}
	\item Как и в TLSv1. 2, рукопожатие начинается с сообщения «Client Hello» — с одним значимым изменением: клиент посылает перечень поддерживаемых наборов шифров и угадывает, какой протокол согласования выберет Сервер. Дополнительно к этому он отправляет свой общий ключ для этого конкретного протокола согласования ключей.
	\item В ответ на сообщение клиента«Client Hello» сервер отвечает «Server Hello», посылает свой сертификат, а также если был угадан протокол шифрования, и сервер на него согласился, то он отсылает свой публичный ключ, генерирует сеансовый ключ и передает «Server Finished».
	\item Клиент проверяет сертификат сервера и так как у него есть публичный ключ сервера, генерирует свой сеансовый ключ и отправляет «Client Finished». С этого момента начинается шифрование данных.
\end{enumerate}
Сообщение «Server Finished», которое было отправлено на 6-ом этапе рукопожатия TLSv1.2, отправляется на втором этапе. Таким образом, экономя четыре шага и одну пересылку туда и обратно по пути.
\addimg{pix/TLS_3}{0.8}{Процесс рукопожатия для TLSv1.3}{pix1v3}
\newpage

\subsection{Сертификаты TLS/SSL}
\subsubsection{Защита данных от ``человека посередине''}
Рассмотрим передачу данных между клиентом и сервером (рис. \ref{1_CS} а). В качестве клиента могут выступать: браузер, мобильное приложение.
\addtwoimgherepro{pix/1_CS}{pix/2_CS}{а) Передача данных между клиентом и сервером\\ б) Подмена ключей во время запроса (зеленым цветом обозначен публичный ключ, красным --- приватный) }{1_CS}{0.3}{0.4}
Изначально, если в эту систему встроится человек, посередине, между клиентом и сервером, то он сможет перехватывать и подменять данные в этой передачи. Чтобы не допустить этого, можно использовать алгоритмы шифрования. 
Симметричное шифрование не подходит, так как для его использования необходимо шифровать одним и тем же ключом шифрования на клиенте и на сервере, а для его передачи нет защищенного канала.

Следовательно, необходимо использовать ассиметричное шифрование: в этом случае у клиента и сервера генерируется по два ключа. Один из ключей --- открытый, с его помощью шифруется информация, другой --- закрытый, им информация расшифровывается. Открытые ключи можно передавать по незащищенному каналу, так как с их помощью нельзя расшифровать данные. Закрытые же ключи хранятся только на сервере и у клиента, следовательно, при перехвате информации её нельзя дешифровать.
Однако существует проблема (рис. \ref{1_CS} б): если кто-то перехватывает данные на этапе обмена ключами, то он может сгенерировать свою пару ключей и на запрос клиента к серверу ``отдать публичный ключ'' отправлять свой. На запрос сервера --- аналогично. Таким образом все данные, которые проходят через посредника, могут быть дешифрованы и заменены.

Чтобы гарантировать целостность данных, можно использовать цифровую подпись: берется некоторый файл, в него записывается публичный ключ владельца и подписывается цифровой подписью. Цифровая подпись --- хэш от документа, в том числе и от публичного ключа, который шифруется приватным ключом владельца. Так как ни у кого еще нет приватного ключа, то никто больше не может поставить цифровую подпись на данный файл.

Проверка целостности файла проходит следующим образом: получатель расшифровывает с помощью публичного ключа, указанного в этом же документе, цифровую подпись и сравнивает хеш, который был расшифрован с хешем, посчитанным от документа. Если хеш совпадает, то можно считать, что атаки не было и целостность не нарушена.

Однако это не исключает возможности того, что атакующий сгенерирует свой собственный документ, на основе своих же ключей и отправит клиенту.

Эту проблему можно решить, если документы будут подписываться не на стороне сервера, а у посредника --- доверенного центра, который имеет свои собственные приватный и публичный ключ. Доверенный центр подписывает с помощью своего приватного ключа документ, сгенерированный на стороне сервера. В этом случае схема взаимодействий  будет выглядеть следующим образом (рис. \ref{3_CS}):
\addimg{pix/3_CS}{0.9}{Проверка целостности с использованием доверенного центра}{3_CS}
Клиент запрашивает два документа, первый от доверенного центра, второй от сервера, подписанный доверенным центром. Первый документ необходим для того, чтобы можно было расшифровать подпись второго документа и проверить целостность.

Данная схема уязвима, если атакующий может выпустить сразу два документа, поэтому для гарантии целостности придется увеличить количество доверенных центров и во главе всей этой цепочки (рис. \ref{4_CS}) установить корневой документ, который никто не подписывает и не пересылает по сети, т.к. он прошивается в клиент.
\addimg{pix/4_CS}{1}{Конечная цепочка подписей}{4_CS}

Использованные документы с подписью и публичным ключом называются цифровым сертификатом.

Цифровой сертификат --- выпущенный удостоверяющим центром электронный документ, подтверждающий принадлежность владельцу открытого ключа или каких-либо атрибутов.

Доверенный центр --- центр сертификации (CA -- Center Authority) --- сторона (отдел, организация), чья честность неоспорима, а открытый ключ широко известен. Задача центра сертификации --- подтверждать подлинность ключей шифрования с помощью сертификатов электронной подписи. 
\newpage

\subsubsection{Виды цифровых сертификатов}

\textit{Сертификат сервера TLS/SSL.}

Протокол TLS, а также его предшественник SSL, обеспечивают безопасность связи между клиентом и сервером. Протокол требует от сервера предъявить цифровой сертификат, подтверждающий, что он является адресатом. Подключающийся клиент проводит проверку сертификата, убеждаясь, что:
\begin{enumerate}
	\item Субъект сертификата совпадает с именем хоста, к которому пытается подключиться клиент.
	\item Сертификат подписан доверенным центром сертификации.
\end{enumerate}
После успешной проверки сертификата клиент может установить зашифрованное соединение с сервером.

\textit{Сертификат клиента TLS/SSL.}

Клиентские сертификаты удостоверяют подлинность клиента, который подключается к сервису TLS, например, для контроля доступа. Так как большинство служб предоставляют доступ к людям, а не устройствам, то большинство клиентских сертификатов содержат адрес электронной почты или собственное имя, а не название хоста. Помимо этого, центр сертификации, выпускающий клиентский сертификат, как правило, является поставщиком услуг, к которому подключается клиент, так как именно он должен выполнять аутентификацию.

Клиентские сертификаты чаще всего используются в VPN сетях и удаленном доступе, где они аутентифицируют устройства.

\textit{Сертификат электронной почты.}

В рамках протокола S/MIME сертификаты электронной почты позволяют как обеспечивать целостность сообщений, так и осуществлять их шифрование. Чтобы установить зашифрованную связь по email, общающиеся стороны должны предварительно обзавестись цифровыми сертификатами. Каждая из сторон должна отослать электронное письмо с цифровой подписью и согласиться на импортирование сертификата отправителя.

Чаще всего S/MIME применяется при общении в рамках определенной организации, где действует собственный центр сертификации, который пользуется доверием участников системы электронной почты.

\textit{Самозаверенные и корневые сертификаты.}

Самозаверенный сертификат --- это такой сертификат, у которого субъект совпадает с издателем, а сигнатура может быть проверена своим открытым ключом.

Цепочка доверия цифровых сертификатов начинается с самозаверенного сертификата, называемого ``корневым сертификатом''. Центр сертификации самостоятельно подписывает корневой сертификат для того, чтобы подписывать другие сертификаты.

Промежуточный сертификат предназначен для той же цели, что и корневой сертификат  --- подписывать  сертификаты. Но при этом промежуточный сертификат --- не самоподписанный и,  соответственно, должен быть подписан корневым сертификатом или другим промежуточным сертификатом. Сертификат конечного объекта - любой сертификат, который не подписывает другие сертификаты. К примеру, сертификаты сервера и клиента TLS/SSL, сертификаты электронной почты --- все это сертификаты конечного объекта.

\subsubsection{Генерация сертификатов, работа с OpenSSL}

Генерация самозаверенного сертификата производилась при помощи утилиты OpenSSL.

OpenSSL - это надежный, коммерческий, полноценный набор программных средств с открытым исходным кодом для реализации протокола TLS. Реализация протокола основана на полнофункциональной криптографической библиотеке общего назначения, которая также может использоваться автономно.

Чтобы создать секретный ключ для коренного (доверенного) TLS сертификата, была выполнена команда:
\begin{minted}[]{C}
openssl genrsa -out ca.key 2048
\end{minted}
При помощи полученного ключа был создан корневой сертификат:
\begin{minted}[]{C}
openssl req -x509 -sha256 -new -nodes -key ca.key -days 365 -out ca.crt
\end{minted}
Чтобы выпустить сертификат для сервера, был так же сгенерирован секретный ключ:
\begin{minted}[]{C}
openssl genrsa -out server.key 2048
\end{minted}
После этого был создан CSR запрос на выпуск сертификата:
\begin{minted}[]{C}
openssl req -new -key server.key -out server.csr
\end{minted}
И затем, при помощи этих двух файлов, создан сертификат для сервера:
\begin{minted}[]{C}
openssl x509 -sha256 -req -in server.csr -CA ca.crt -CAkey ca.key \
-CAcreateserial -out server.crt -days 365
\end{minted}
Аналогично был создан сертификат для клиента:
\begin{minted}[]{C}
openssl genrsa -out client.key 2048
openssl req -new -key client.key -out client.csr
openssl x509 -sha256 -req -in client.csr -CA ca.crt -CAkey ca.key \
-CAcreateserial -out client.crt -days 365
\end{minted}
Подробную информацию об использованных ключах можно найти в документации  OpenSSL\cite{Openssl}.

\subsection{Инструменты и технологии, использованные при создании серверного приложения}

Серверное приложение написано на языке программирования Си.
Это связано с тем, что основные вычисления должны производиться на серверной части проекта, а Си является одним из самых быстрых высокоуровневых языков программирования. Также Си является переносимым (кроссплатформенным) языком, то есть программа, написанная на Си для одной вычислительной системы, может быть перенесена в другую с незначительными изменения, либо же вообще без них.

В качестве редактора исходного кода был использован Visual Studio Code, так как он позволяет выполнять быструю навигацию по коду, автоматически дополняет типовые конструкции и выводит контекстные подсказки.

Для отладки использовался LLDB, а для проверки на наличие утечек памяти Valgrind.

\subsection{Инструменты и технологии, использованные при создании клиентского приложения}

Так как для клиентского приложения предполагалось наличие графического интерфейса, то для реализации был выбран язык программирования Python с использование фреймворка kivy.

Kivy --- это бесплатный фреймворк Python с открытым исходным кодом для разработки мобильных приложений и другого мультитач-прикладного программного обеспечения с естественным пользовательским интерфейсом. Он распространяется на условиях лицензии MIT и может работать на Android, iOS, Linux, macOS и Windows.

В качестве редактора исходного кода был использован Visual Studio Code.

Для сборки приложения в apk файл был использован Buildozer --- это утилита, предназначенная для легкой сборки мобильных приложений. Он автоматизирует весь процесс сборки, загружая предварительные условия, такие как python-for-android, Android SDK, NDK и т.д.

Для тестирования приложения был использован телефон Xiaomi Redmi Note 9 на ОС Andriod 11, API level 29, разрядность 64 бит. Он был разблокирован для отладки по USB и применялся Android Debug Bridge (ADB).