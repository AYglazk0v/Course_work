

\section{РАЗРАБОТАННОЕ ПРОГРАММНОЕ ОБЕСПЕЧЕНИЕ}

\subsection{Реализованные возможности приложения}

Согласно поставленной задачи было разработано приложение позволяющее синхронизировать выбранные каталоги с файлами и все подкаталоги между ПК и мобильным устройством через WiFi по защищенному каналу. 

В приложении реализованы следующие функции: 
\begin{enumerate}
	\item Однонаправленная синхронизация с телефона на ПК --- при такой синхронизации, если на телефоне существует файл с более новым таймкодом, чем на ПК, то на компьютере он будет заменен и его время модифицировано.
	\item Однонаправленная синхронизация с ПК на телефон --- аналогично предыдущему, но в другом направлении.
	\item Двунаправленная синхронизация --- эта синхронизация представляет совокупность предыдущих и в результате её выполнения на устройствах будут одинаковые версии файлов.
	\item Удаленное завершение работы серверного ПО.
\end{enumerate}

Приложение способно отлавливать конфликты типов данных: если на одном из устройств существует каталог, а на другом файл, с одинаковыми именами, то сообщение об этом будет выведено в терминал на ПК и на экран телефона.

Синхронизация происходит на основе последней даты модификации, если на устройствах существует один и тот же файл, но у него разное время модификации, то вследствие выполнения синхронизации, файл с более старым временем модификации будет заменен, на второй и у него будет установлен тот же таймкод. 

Так как приложение не ведет логирование, то разное время модификации не считается конфликтом и файл будет синхронизирован по последнему времени модификации.

\subsection{Архитектура серверной части}

Серверная часть ПО выполнялась на ПК с ОС Linux, Ядро: 5.17.7-arch1-2.

Для реализации проекта (сервер), были использованы следующие библиотеки:
\begin{enumerate}
	\item unistd.h --- для использования системных вызовов \verb|write()|, \verb|read()|, \verb|close()|, а также функций \verb|access()| и \verb|chdir()|.
	\item stdio.h --- для использования функций \verb|remove()| и \verb|printf()|.
	\item stdlib.h --- для использования функций \verb|malloc()|, \verb|free()|, \verb|exit()|.
	\item string.h --- для использования функций \verb|strcmp()|, \verb|bzero()|, \verb|strlen()|.
	\item sys/types.h --- для использования структур и типов \verb|size_t|, \verb|time_t|.
	\item sys/stat.h --- для использования структуры \verb|time_t| и функций \verb|stat()| и \verb|mkdir()|.
	\item fcntl.h --- для получения параметров управления файлом и использования функции \verb|open()|.
	\item errno.h --- для идентификации ошибок через их код.
	\item dirent.h --- для  работы с форматом записей каталога, а также  для использования структуры \verb|DIR| и функций  \verb|closedir()|, \verb|opendir()|, \verb|readdir()|.
	\item netinet/in.h --- для определения семейство интернет-адресов и использования структуры \verb|sockaddr_in|.
	\item sys/socket.h --- для подключения семейства интернет-протоколов и использования структур  \verb|sockaddr|, \verb|socklen_t|, а также функций \verb|accept()|, \verb|bind()|, \verb|connect()|, \verb|listen()|, \verb|setsockopt()|, \verb|shutdown()|, \verb|socket()|.
	\item arpa/inet.h --- для определения для интернет-операций и функций \verb|htons()|, \verb|ntohs()|, \verb|inet_ntoa()|.
	\item openssl/ssl.h --- для подключения функций криптографической библиотеки openssl и обеспечении соединения, а также верификации по протоколу tls.  
	\item openssl/err.h --- для идентификации ошибок при использовании криптографической библиотеки.
	\item ifaddrs.h --- для использования структуры \verb|ifaddrs| и функций \verb|getifaddrs()|, \verb|freeifaddrs()|.
	\item netdb.h --- для использования функции \verb|getnameinfo()|.
	\item time.h --- для использования структуры tm, и функций \verb|mktime()|, \verb|localtime()| и \verb|strptime()|.
	\item utime.h --- для использования структуры utimbuf  и функции \verb|utime()|.
\end{enumerate}

\subsection{Архитектура клиентской части}

Минимальным требованием для работы приложения является Android 5.0, API Levels 21.

Для реализации клиентской части проекта, были применены модули, указанные в таблице \ref{table1}.
%\begin{enumerate}
%	\item kivymd.app --- Этот модуль содержит класс MDApp, который наследуется от kivy.app.App. MDApp имеет некоторые свойства, необходимые для библиотеки KivyMD.
%	\item kivymd.uix.dialog --- Данный модуль используется для реализации диалоговых окон.
%	\item kivymd.uix.button --- Данный модуль используется для реализации кнопок.
%	\item kivymd.uix.filemanager --- Данный модуль используется для реализации файлового менеджера.
%	\item kivymd.toast --- Используется для вывода уведомления на экран.
%	\item kivy.uix.screenmanager --- Модуль, предназначенный для управления несколькими экранами приложения.
%	\item kivy.lang --- Модуль для описания графического интерфейса.
%	\item kivy.uix.boxlayout --- Модуль для импорта менеджера компоновки элементов.
%	\item kivy.properties --- Модуль для получения-передачи информации с виджетов.
%	\item kivy.utils --- Предоставляет выбор общих полезных функций и классов, используется для получения информации о используемой платформе.
%	\item datetime --- Модуль предоставляет классы для управления датами и временем.
%	\item socket --- Данная библиотека обеспечивает доступ к сокетам.
%	\item ssl --- Этот модуль предоставляет доступ к средствам шифрования и аутентификации TLS для сетевых сокетов, как на стороне клиента, так и на стороне сервера. Этот модуль использует библиотеку OpenSSL.
%	\item pathlib --- Этот модуль предлагает классы, представляющие путь файловой системы с семантикой, подходящей для различных операционных систем. 
%	\item time ---  Этот модуль предоставляет различные функции, связанные со временем, необходим для использования функции \verb|mktime()|.
%	\item os --- Модуль для использования функций ОС, такие как \verb|remove()|, \verb|chdir()|, \verb|open()|, \verb|close()|.
%	
	\begin{table}[H]
		\caption{Модули Python примененные в разработки клиентского приложения}
		\label{table1}
		\begin{tabular}{|l|l|}
			\hline
			Модуль                 & Назначение                                         \\ \hline
			kivymd.app & \begin{tabular}[c]{@{}l@{}}содержит класс MDApp, который имеет свойства,\\ необходимые для библиотеки KivyMD\end{tabular}           \\ \hline
			kivymd.uix.dialog      & реализации диалоговых окон                         \\ \hline
			kivymd.uix.button      & реализации кнопок                                  \\ \hline
			kivymd.uix.filemanager & реализации файлового менеджера                     \\ \hline
			kivymd.toast           & вывод уведомлений на экран                         \\ \hline
			kivy.lang              & описание графического интерфейса                   \\ \hline
			kivy.uix.screenmanager & управление несколькими экранами приложения         \\ \hline
			kivy.uix.boxlayout     & импорт менеджера компоновки элементов              \\ \hline
			kivy.properties        & получение-передача информации с виджетов           \\ \hline
			kivy.utils             & получение информации о используемой платформе      \\ \hline
			datetime               & управление датами и временем                       \\ \hline
			socket                 & доступ к сокетам                      \\ \hline
			ssl                    & доступ к средствам шифрования и аутентификации TLS \\ \hline
			pathlib    & \begin{tabular}[c]{@{}l@{}}получение  пути файловой системы с семантикой,\\  подходящей для различных операционных систем\end{tabular} \\ \hline
			time                   & для использования функции \verb|mktime()|                 \\ \hline
			os                     & использование функция ОС                           \\ \hline
		\end{tabular}
	\end{table}

\subsection{Файловая структура серверного приложения}

Серверная реализация состоит из двух каталогов и Makefile.
В первом каталоге --- includes --- хранятся заголовочные файлы, необходимые для объявления функций, определения макросов и совместного использования несколькими исходными файлами. Назначение заголовочных файлов описано в таблице \ref{table2}.

\begin{table}[H]
	\caption{Заголовочные файлы и их назначение}
	\label{table2}
	\begin{tabular}{|l|l|}
		\hline
		Файл &
		Назначение \\ \hline
		./includes/funcRecvRespList.h &
		\begin{tabular}[c]{@{}l@{}}объявление функций \\     \verb|fn_pushBackRec()|, \verb|fn_removeListsRec|,\\ \verb|fn_initListRecResp()| и структур \verb|s_listRec|,\\ \verb|s_listsRecResp|.\end{tabular} \\ \hline
		./includes/get\_next\_line.h &
		объявление функции \verb|get_next_line()|. \\ \hline
		./includes/listOfFiles.h &
 		 \begin{tabular}[c]{@{}l@{}}объявление функции \verb|fn_writeListDir()| \\ и структуры \verb|s_find_f|.\end{tabular} \\ \hline
		./includes/timingModes.h &
		\begin{tabular}[c]{@{}l@{}}объявление функции \verb|fn_timingModes()|\\  и структур \verb|s_fileConversion| и \verb|s_list|.\end{tabular} \\ \hline


		./includes/utils.h &
		\begin{tabular}[c]{@{}l@{}}объявление функций \verb|fn_cleanDict()|, \verb|fn_strnstr()|,\\ \verb|fn_existDir()|, \verb|fn_split()|, \verb|fn_getBreakdown()|,\\ \verb|fn_setTimes()|.\end{tabular} \\ \hline
		
		./includes/main.h &
		\begin{tabular}[c]{@{}l@{}}объявление функция \verb|fn_checkStartDir()|,\\ \verb|fn_connetion()| и структуры \verb|s_info|.\end{tabular} \\ \hline
	\end{tabular}
\end{table}
Реализации структур приведена ниже:
\begin{minted}[]{C}
/*
      Вспомогательная структура алгоритма синхронизации,
      содержащая в себе поля с данными о файлах,
      которые будут синхронизированы.
*/
struct s_listRec
{
      char       *data; //Строка для хранения имени файла.
      char       *time; //Строка для хранения времени,
	                  // которое нужно будет установить.
      t_listRec  *next; //Указатель на следующий элемент списка.
      t_listRec  *prev; //Указатель на предыдущий элемент списка.
};
\end{minted}
\newpage
\begin{minted}[]{C}
/*
      Основная структура алгоритма синхронизации, содержащая в себе
      поля со списками файлов, которые необходимо 
      синхронизировать в определенном направлении.
*/
typedef struct	s_listsRecResp
{
      t_listRec	*fwriteRec; //перечень файлов, которые будут
      	                    // отправлены на телефон.
      t_listRec	*freadRec; //перечень файлов, которые будут
      	                    // отправлены на сервер.
      t_listRec	*dwriteRec; //перечень директорий, которые будут
      	                     // отправлены на телефон.
      t_listRec	*dreadRec; //перечень директорий, которые будут
      	                    //отправлены на сервер.
      t_listRec	*conflict; //перечень конфликтующих файлов.
}    t_listsRecResp;

/*
      Структура используемая для создания .s_files,
      содержащего перечень всех файлов в директории и их таймкодов
*/
typedef struct	s_find_f
{
      int            fd; //Файловый дескриптор для открытия файла ".s_files".
      struct dirent  **namelist; //Структура хранящая перечень
                                 // файлов в каталоге.
      char           t_buf[15]; //Строка для записи времени модификации.
      struct tm      *tm; //Структура для помощи в конвертации из stat в char*
                          // и послед. записи в файл.
      struct stat    times; //Структура для получения информации о файле
                            // с помощью stat().
}t_find_f;
	
	

/*
      Вспомогательная структура для парсинга файлов .s_files и .c_files
*/
struct s_list
{
      char	**data; //Массив строк, хранящий name, time и поле DIR,
                         //если файл -- каталог
      t_list	*next; // Указатель на следующий элемент списка
      t_list	*prev; // Указатель на предыдущий элемент списка
};
	
/*
      Основная структура для парсинга файлов .s_files и .c_files.
*/
typedef struct s_fileConversion
{
      t_list	*s_head; //Указатель на первый элемент списка файлов сервера
      t_list	*c_head; //Указатель на первый элемент списка файлов клиента
      int	    s_size; //Количество элементов в списке сервера
      int	    c_size; //Количество элементов в списке клиента
}  t_fileConversion;

/*
      Основная структура программы, содержащая в себе используемые переменные.
*/
typedef struct s_info
{
      char        *s_dir; //Строка хранящая стартовую директорию
      char        buff[MAXBUF]; //Буфер для работы с файлами
      int	 fd_serv, fd_client, fd; // Файловые дескрипторы
      socklen_t   sock_len; //Беззнаковый целочисленный тип длины >= 32 бит. 
      SSL_CTX     *ctx; //Контекст (настройка параметров) для TLS соединения.
      SSL         *ssl; //Объект типа ssl
      struct  sockaddr_in    server_addr, client_addr; //Адрес и порт сервера
                                                   //и клиента соответственно.
}  t_info;
\end{minted}
\newpage
Во втором каталоге --- src --- находятся два подкаталога (GNL и utils) и четыре .с файла, в них находятся реализации функций, необходимых для работы серверной части проекта. Назначение файлов указано в таблице \ref{table3}.

\begin{table}[H]
	\caption{Файлы проекта и их назначение}
	\label{table3}
	\begin{tabular}{|l|l|}
		\hline
		Файл                           & Описание                                                                                                                          \\ \hline
		./src/main.c                   & \begin{tabular}[c]{@{}l@{}}главный файл программы, содержащий функцию \\ \verb|main()| \end{tabular}\\ \hline
		./src/funcRecvRespList.c       & \begin{tabular}[c]{@{}l@{}}содержит реализации функций для работы \\ со структурой \verb|t_listsRecResp|\end{tabular}              \\ \hline
		./src/timingModes.c &
		\begin{tabular}[c]{@{}l@{}}содержит реализацию функций для заполнения \\ основной структуры синхронизации на основе типа \\синхронизации, выбранного клиентом  и полученного\\ файла .c\_files\end{tabular} \\ \hline
		./src/serv.c                   & \begin{tabular}[c]{@{}l@{}}содержит функции для установления соединения с\\ клиентом и последующей синхронизации\end{tabular} \\ \hline
		./src/utils/split.c                & \begin{tabular}[c]{@{}l@{}}содержит реализацию функции, позволяющей\\ разделить строку на подстроки по сепаратору\end{tabular}    \\ \hline
		./src/utils/listOfFiles.c &
		\begin{tabular}[c]{@{}l@{}}содержит реализацию функции для создания файла\\ .s\_files, содержащего список файлов в директории и\\их временные метки\end{tabular} \\ \hline
		./utils/checkStartDir.c &
		\begin{tabular}[c]{@{}l@{}}содержит реализацию функции для проверки наличия\\  в домашнем каталоге директории ``CourseWorkProject''\end{tabular} \\ \hline
		./src/utils/modification\_time.c   & \begin{tabular}[c]{@{}l@{}}содержит реализацию функции для установления\\ времени модификации на файл\end{tabular}               \\ \hline
		./src/utils/getbrekdown.c &
		\begin{tabular}[c]{@{}l@{}}файл, в котором реализована разбивка строки\\  формата ``utils 19970221153550 DIR'' на подстроки\\ вне зависимости от наличия isspace\\ символов в названии файла\end{tabular} \\ \hline
		./src/utils/utils\_0.c             & \begin{tabular}[c]{@{}l@{}}содержит вспомогательные функции, \\ которые часто используются во всем проекте\end{tabular}           \\ \hline
		./src/GNL/get\_next\_line.c        & \begin{tabular}[c]{@{}l@{}}содержит реализацию функции для получения\\ подстроки из файла по символу переноса строки\end{tabular} \\ \hline
		\begin{tabular}[c]{@{}l@{}}./src/GNL/$\backslash${}\\get\_next\_line\_utils.c \end{tabular}& \begin{tabular}[c]{@{}l@{}}содержит вспомогательные функции для \\ реализации \verb|get_next_line()|\end{tabular}                      \\ \hline
	\end{tabular}
\end{table}
\newpage
Рассмотрим содержимое файлов каталога src:
\begin{enumerate}
	\item main.c --- главный файл программы, содержащий функцию \verb|main()|, в теле которой вызываются: 
	
	\verb|fn_checkStartDir()| --- для получения стартовой директории синхронизации, либо создание таковой, если её нет; 
	
	\verb|fn_connetion()| --- для выполнения соединения с клиентом и последующей синхронизации;
	\item funcRecvRespList.c --- файл, содержащий реализации функций для \verb|t_listsRecResp| такие как: 
	
	\verb|static char	*fn_strdup(const char *str)| --- функция создает дубликат строки \verb|(str)| с условием выделения памяти. Возвращает указатель на новую строке, либо \verb|NULL| в случае неудачи;
	
	\verb|static t_listRec	*fn_getLast(t_listRec *head)| --- функция для получения последнего экземпляра \verb|t_listRec| в списке \verb|(head)|.Возвращает указатель на последний \verb|t_listRec|, если существует \verb|head|, иначе \verb|NULL|;
	
	\verb|static void	fn_delElem(t_listRec **head, t_listRec *delElem)| --- функция для удаления элемента \verb|(delElem)| в списке \verb|(head)|;
	
	\verb|void	fn_initListRecResp(t_listsRecResp *env)| --- функция для инициализации структуры \verb|t_listsRecResp|;
	
	\verb|void	fn_removeListsRec(t_listsRecResp *env)| --- функция для очистки стркутуры \verb|t_listsRecResp|;
	
	\verb|void	fn_pushBackRec(t_listRec **head, char *date, char *time)| ---  функция для создания нового экземпляра \verb|t_listRec| в конец списка \verb|(head)| и заполнения его полей \verb|date, time|. В случае ошибки выделения памяти под новый элемент вызывается ошибка и программа завершается;
	
	\item  timingModes.c --- файл, содержащий внутри себя функции для заполнения структуры \verb|s_listsRecResp| на основе выбранного режима синхронизации и полученного .c\_files.  файла.
	
	Функции:
	
	\verb|static void		fn_initList(t_fileConversion *env)| --- инициализация структуры \verb|t_fileConversion|;
	
	\verb|static t_list	*fn_getLast(t_list *head)| --- функция для получения последнего экзмепляра \verb|t_list| в списке \verb|(head)|. Возвращает указатель на последний \verb|t_list|, если существует \verb|head|, иначе \verb|NULL|;
	
	\verb|static void		fn_delElem(t_list **head, t_list *delElem)| --- функция для удаления элемента \verb|(delElem)| в списке \verb|(head)|;
	
	\verb|static void		fn_pushBack(t_list **head, char *date)| --- функция для создания нового экземпляра \verb|t_list| в конец списка \verb|(head)| и заполнения его полей \verb|date, time|. В случае ошибки выделения памяти под новый элемент вызывается ошибка и программа завершается;
	
	\verb|static void		fn_removeLists(t_fileConversion *env)| --- функция для очистки структуры \verb|t_fileConversion|;
	
	\verb|static void		fn_strConversion(t_list **head, const char *src)| --- функция для заполнения листа \verb|(head)| данными из файла \verb|(src)|;
	
	\verb|static void		fn_c2s(t_listsRecResp *recv)| --- функция заполняет поля структуры \verb|(recv)| согласно типу синхронизации, однонаправленная синхронизация данных с клиента на сервер;
	
	\verb|static void		fn_s2c(t_listsRecResp *recv)| --- функция заполняет поля структуры \verb|(recv)| согласно типу синхронизации, однонаправленная синхронизация данных с сервера на клиент; 
	
	\verb|static void		fn_bilateral(t_listsRecResp *recv)| --- функция заполняет поля структуры \verb|(recv)| согласно типу синхронизации, двунаправленная синхронизация данных;
	
	\verb|void			fn_timingModes(t_listsRecResp *recLst, char *s)| --- функция осуществляет заполнение структуры \verb|(recLst)| в соответствии с выбранным на клиенте типом синхронизации \verb|(s)|;
	
	\item serv.c --- файл содержащий реализацию подключения и синхронизации данных.
	
	Функции:
	
	\verb|static void	fn_initServerCTX(t_info *inf)| --- функция для инициализации контекста SSL;
	
	\verb|static void	fn_loadCertificates(t_info *inf, char *CertFile,|
	\verb|char *KeyFile, char *RootFile)| --- функция для загрузки и настройки проверки верификации по сертификатам;
	
	\verb|static void	fn_printWlanIP(void)| --- функция печатающая сетевой интерфейс и IP адрес устройства;
	
	\verb|static void	fn_openListener(t_info *inf)| --- функция инициализирующая сокет и прослушивание порта;
	
	\verb|static void	fn_GetDirPhone(t_info *inf)| --- функция для перехода (создания, если не было) в директорию синхронизации;
	
	\verb|static void	fn_receive_c_file(t_info *inf)| --- функция для получения файла .c\_files с клиента;
	
	\verb|static void	fn_receivingFiles(t_listRec *curr, t_info *inf)| --- функция для получения файла с клиента на сервер;
	
	\verb|static void	fn_sendingFiles(t_listRec *curr, t_info *inf)| --- функция для отправки файла с сервера на клиент;
	
	\verb|static void	fn_receiveDir(t_listRec *curr, t_info *inf, char* c)| --- функция для получения директории с клиента на сервер;
	
	\verb|static void	fn_sendDir(t_listRec *curr, t_info *inf, char* c)| --- функция для отправки директории с сервера на клиент;
	
	\verb|static void	fn_confilctFile(t_listRec *curr, t_info *inf)| --- функция для отправки и вывода информации о конфликтующих файлах;
	
	\verb|static void	fn_solver(char *c, t_info *inf)| --- функция для выполнения синхронизации;
	
	\verb|void	fn_connetion(t_info *inf)| --- функция для выполнения соединения с клиентом и последующей синхронизации;
\end{enumerate}
В подкаталоге --- utils --- располагаются файлы с реализациями общих функций, которые используются повсеместно.

Рассмотрим содержимое каталога:
\begin{enumerate}
	\item split.c --- файл для реализации функции разделения строки на подстроки по сепаратору.
	
	Функции:
	
	\verb|static char	**fn_clear(char **tab)| --- функция для очистки указателя на указатель (массив строк) в случае ошибки выделения памяти. Пробрасывает \verb|NULL| в вызываемую функцию;
	
	\verb|static size_t	fn_strlen2sep(const char *str, char sep)| --- функция для подсчета символов в строке \verb|(str)| до следующего разделителя \verb|(sep)|. Возвращает количество символов;
	
	\verb|static size_t	fn_count_words(const char *str, char sep)| --- Функция для подсчета ``слов'' в строке \verb|(str)| с условием разделения по сепаратору (sep); Возвращает количество ``слов'';
	
	\verb|char	**fn_split(char *s, char c)| --- функция разбивает строку \verb|(s)| по сепаратору \verb|(c)| и возвращает указатель на указатель (массив строк), оканчивающийся \verb|NULL|;
	
	\item listOfFiles.c --- файл содержит единственную функцию:\\\verb|void	fn_writeListDir(void)|,  которая создает временный файл .s\_file содержащий перечень файлов и директорий находящихся в текущем рабочем каталоге в алфавитном порядке.
	
	\item checkStartDir.c --- файл содержит функции для проверки наличия в домашнем каталоге директории для синхронизации ``CourseWorkProject''.
	
	Функции: 
	
	\verb|static char	*fn_strjoin(char *s1, char *s2)| --- функция для склейки двух строк \verb|(s1, s2)|. Возвращает указатель на новую строку в случае успеха, иначе \verb|NULL|.
	
	\verb|static char	*fn_parsHome(char **env)| --- функция для получения домашней директории путем парсинга переменного окружения \verb|env|. Возвращает строку, если такая найдена, иначе программа завершается с выводом ошибки.
	
	\verb|void	fn_checkStartDir(t_info *inf)| --- функция для проверки существования каталога синхронизации в домашней директории. Если директория не существует, то пользователю предлагается создать её. Если в домашней директории существует одноименный файл, не являющийся директорий, то выводится ошибка и программа завершается. Иначе происходит модификация \verb|inf->s_dir|: склеивается с ``\~{}/CourseWorkProject''. Возвращает строку, если такая найдена, иначе программа завершается с выводом ошибки;
	
	\item  modification\_time.c --- файл содержит единственную функцию: 
	
	\verb|void	fn_setTimes(char *name, char *times)|, которая устанавливает на файл или каталог время модификации. Входные параметры: \verb|name| -- имя файла или каталога, на который будет установлено время; \verb|times| -- время, которое будет установлено в строковом представлении; формат строки --- YearMonthDayHourMinuteSecond.;
	
	\item utils\_0.c --- содержит такие функции, как:
	
	\verb|void	fn_cleanDict(char **dict)| --- функция для очистки указателя на указатель (массив строк);
	
	\verb|char	*fn_strnstr(const char *haystack, const char *needle, size_t len)| --- функция для поиска подстроки \verb|(needle)| в строке \verb|(haystack)| до \verb|len| символов. Возвращает указатель на первое вхождение, либо \verb|NULL|, если таковое не найдено.
	
	\verb|int	fn_existDir(char *path)| --- функция для проверки существования директории \verb|(path)|. Возвращает \verb|0| в случае успеха, иначе \verb|-1|.
	
	\item getbrekdown.c --- файл в котором реализована разбивка строки формата ``utils 19970221153550 DIR'' на подстроки вне зависимости от наличия isspace символов в названии файла.
	
	Функции:
	
	\verb|static char	*fn_strrchr(const char *string, int c)| --- функция для поиска последнего вхождения символа в строке, если символ найден, то возвращается указатель на место, где он находится, иначе \verb|NULL|;
	
	\verb|static int	fn_cnt_word(char *s)| --- функция, которая подсчитывает количество слов в исходной строке (может быть либо 3, либо 2) и возвращает их количество;
	
	\verb|static int fn_len_name(char *s)| --- функция для расчета длины имени файла, возвращает целочисленное значение отличное от нуля в случае успеха, иначе нуль.
	
	\verb|char	**fn_getBreakdown(char *s)| --- функция, которая реализует разбивку на подстроки в зависимости от количества параметров (2 или 3), допуская isspace символы в названии файла.
\end{enumerate}
В другом подкаталоге находятся файлы для реализации функции get\_next\_line:
\begin{enumerate}
	\item get\_next\_line.c --- файл содержит функции для реализации получения подстроки до символа \textbackslash{n};
	
	\verb|static char	*fn_strjoin(char *s1, char *s2)| --- функция для склейки строки \verb|s1| со строкой \verb|s2|, в случае успеха возвращается новая строка, иначе \verb|NULL|;
	
	\verb|static char	*fn_read_file(int fd, char *balance_line)| --- функция считывания строки  из файлового дескриптора до того момента, пока в считанном фрагменте не встретится \textbackslash{n}, либо \textbackslash{0};
	
	\verb|static char	*fn_get2n(char *balance_line)| --- функция подстроки до \textbackslash{n};
	
	\verb|static char	*fn_get_nbalance(char *balance_line)| --- функция получения остатка от строки, после символа \textbackslash{n}, чтобы при следующем вызове не потерять остаток.
	
	\item get\_next\_line\_utils.c --- файл, содержащий функции, используемые при получении новой строки:
	
	\verb|size_t	fn_strlen(char *s)| --- функция возвращает длину строки;
	
	
	\verb|char	*fn_strchr(char *string, int symbol)| --- функция возвращает указатель на первое вхождение символа в строке, иначе \verb|NULL|;
	
	\verb|char	*fn_substr(char *s, unsigned int start, size_t len)| --- функция для получения подстроки длины \verb|len| начиная с позиции \verb|start|, в случае успеха возвращается указатель на подстроку, иначе \verb|NULL|;
\end{enumerate}

\subsection{Алгоритм синхронизации}
Рассмотрим основной алгоритм синхронизации данных (рис. \ref{dia}), а именно функцию --- \verb|fn_solver()|.
Изначально создается файл .s\_files с перечнем всех файлов находящихся в синхронизируемой директории на сервере. Для этого используется функция  \verb|fn_writeListDir()|.

Далее необходимо получить .c\_files с информацией о файлах, находящихся в синхронизируемой директории на клиенте. Для этого необходимо отправить соответствующий запрос клиенту и начать запись получаемого файла. Всё это реализуется в функции \verb|fn_receive_c_file()|.

Затем нужно инициализировать и заполнить структуру \verb|t_listsRecResp| для этого реализованы функции \verb|fn_initListRecResp()| и \verb|fn_timingModes()|.
Внутри второй функции в зависимости от флага на синхронизацию происходит заполнение полей.

После того как была заполнена структура, просматривается поле --- \verb|freadRec|, пока не встретится \verb|NULL|, отправляется запрос на получение файлов, находящихся в этом поле, и происходит их запись на сервер. После записи файлов на них устанавливается таймкод клиента.

Когда закончилось поле \verb|freadRec| начинается просмотр поля \verb|fwriteRec|, до такого же момента, но уже каждый раз отправляется запрос на отправку файлов клиенту, передается название файла, сам файл, а затем посылается запрос на установление времени модификации и отправляется таймкод файла с сервера.

После того, как были обнаружены \verb|NULL| в этих полях структуры --- были синхронизированы все файлы в каталоге, однако там еще остались директории, которые тоже могут потребовать синхронизации. Поэтому пока не встретился \verb|NULL| в поле \verb|dreadRec|, происходит попытка создать директорию с именем из текущего экземпляра списка, если этого не получилось, то значит данный каталог уже существует. Далее происходит переход в эту директорию и отправляется запрос клиенту, чтобы он тоже перешел в неё же. После чего заново вызывается функция \verb|fn_solver()|, переходя вниз по стеку вызова. Как только функция \verb|fn_solver()| отработает и программа вернется к предыдущему уровню в стеке, то происходит переход в родительский каталог и отправляется запрос на аналогичные действия клиенту. Далее так как в каталогах создавались файлы, то время модификации на каталогах тоже необходимо синхронизировать, для этого необходимо отправить запрос клиенту на модификацию времени, таймкод, а также на сервере вызвать функцию \verb|fn_setTimes()|, для того, чтобы установить время на синхронизированный каталог.

Для синхронизации директории с сервера на клиент необходимо проделать похожие действия за исключением первого запроса, он изменится на ``\verb|mkdir && cd|'', остальное будет без изменений.

В итоге после этого шага останется только уведомить обе стороны о файлах-конфликтах, если они имеются. Для этого необходимо пройтись по полю \verb|conflict|, пока текущий элемент не \verb|NULL| и отправить запрос на вывод ошибки клиенту, а затем и название файла.

Можно считать синхронизацию завершенной, остается очистить выделенную память: удалить временные файлы со списками файлов, а также освободить использованную структуру.
\addimghere{pix/Diagramm}{0.75}{Блок-схема алгоритма синхронизации}{dia}

%\end{enumerate}
