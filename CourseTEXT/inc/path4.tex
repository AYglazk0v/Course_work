\section{СТРУКТУРА РЕАЛИЗАЦИИ ПРИЛОЖЕНИЯ И АЛГОРИТМ СИНХРОНИЗАЦИИ}

\subsection{Файловая структура серверного приложения}

Серверная реализация состоит из двух каталогов и Makefile.
В первом каталоге --- includes --- хранятся заголовочные файлы, необходимые для объявления функций, определения макросов и совместного использования несколькими исходными файлами (рис. \ref{files2}).
\addimghere{pix/files2}{0.45}{Файловая структура сервера --- includes}{files2}
\begin{enumerate}
	\item funcRecvRespList.h --- заголовочный файл для объявления функций 
		\verb|fn_pushBackRec()|, \verb|fn_removeListsRec|, \verb|fn_initListRecResp()| и структур \verb|s_listRec|, \verb|s_listsRecResp|.
	\item get\_next\_line.h --- заголовочный файл для объявления функции \verb|get_next_line()|.
	\item listOfFiles.h --- заголовочный файл для объявления функции \verb|fn_writeListDir()| и структуры \verb|s_find_f|.
	\item timingModes.h --- заголовочный файл для объявления функции \verb|fn_timingModes()| и структур \verb|s_fileConversion| и \verb|s_list|.
	\item utils.h --- заголовочный файл для объявления функций \verb|fn_cleanDict()|, \verb|fn_strnstr()|, \verb|fn_existDir()|, \verb|fn_split()|, \verb|fn_getBreakdown()|, \verb|fn_setTimes()|.
	\item main.h --- заголовочный файл для объявления функций \verb|fn_checkStartDir()|,
	
		\verb|fn_connetion()| и структуры \verb|s_info|.
\end{enumerate}
Реализации структур приведена ниже:
\begin{minted}[]{C}
typedef struct s_listRec	t_listRec;

/*
	Вспомогательная структура алгоритма синхронизации,
	содрежащая в себе поля с данными о файлах,
	которые будут синхронизированы.
*/
struct s_listRec
{
    char       *data; //Строка для хранения имени файла.
    char       *time; //Строка для хранения времени,
                      // которое нужно будет установить.
    t_listRec  *next; //Указатель на следующий элемент списка.
    t_listRec  *prev; //Указатель на предыдущий элемент списка.
};
\end{minted}
\begin{minted}[]{C}
/*
	Основная структура алгоритма синхронизации, содрежащая в себе
	поля со списками файлов, которые необходимо 
	синхронизировать в определенном направлении.
*/
typedef struct	s_listsRecResp
{
    t_listRec	*fwriteRec; //перечень файлов, которые будут
   			      // отправлены на телефон.
    t_listRec	*freadRec; //перечень файлов, которые будут
   			      // отправлены на сервер.
    t_listRec	*dwriteRec; //перечень директорий, которые будут
   			      // отправлены на телефон.
    t_listRec	*dreadRec; //перечень директорий, которые будут
   			      //отправлены на сервер.
    t_listRec	*conflict; //перечень конфликтующих файлов.
}    t_listsRecResp;




/*
	Структура используемая для создания .s_files,
	содержащего перечень всех файлов в директории и их таймкодов
*/
typedef struct	s_find_f
{
    int		  fd; //Файловый дескриптор для открытия файла ".s_files".
    struct dirent	**namelist; //Структура хранящая перечень
    				 // файлов в каталоге.
    char	 	t_buf[15]; //Строка для записи времени модификации.
    struct tm    	*tm; //Структура для помощи в конвертации из stat в char*
    			  // и послед. записи в файл.
    struct stat	  times; //Структура для получения информации о файле
    			    // с помощью stat().
}t_find_f;

typedef struct s_list		t_list;

/*
	Вспомогательная структура для парсинга файлов .s_files и .c_files
*/
struct s_list
{
    char	**data; //Массив строк, хранящий name, time и поле DIR,
    		    //если файл -- каталог
    t_list	*next; // Указатель на следующий элемент списка
    t_list	*prev; // Указатель на предыдущий элемент списка
};








/*
	Основная структура для парсинга файлов .s_files и .c_files.
*/
typedef struct s_fileConversion
{
    t_list	*s_head; //Указатель на первый элемент списка файлов сервера
    t_list	*c_head; //Указатель на первый элемент списка файлов клиента
    int	    s_size; //Количество элементов в списке сервера
    int	    c_size; //Количество элементов в списке клиента
}  t_fileConversion;

/*
	Основная структура программы, содрежащая в себе
	частоиспользуемые переменнные.
*/
typedef struct s_info
{
    char        *s_dir; //Строка хранящая стартовую директорию
    char        buff[MAXBUF]; //Буфер для работы с файлами
    int	 fd_serv, fd_client, fd; // Файловые дескрипторы
    socklen_t   sock_len; //Беззнаковый целочисленный тип длины не менее 32 бит. 
    SSL_CTX     *ctx; //Контекст (настройка параметров) для TLS соединения.
    SSL         *ssl; //Объект типа ssl
    struct   sockaddr_in	server_addr, client_addr; //Адрес и порт сервера
    					           //и клиента соответсвенно.
}  t_info;
\end{minted}
\newpage
Во втором каталоге --- src --- находятся два подкаталога (GNL и utils) и четыре .с файла, в них находятся реализации функций, необходимых для работы серверной части проекта, назначение файлов указано в таблице \ref{}.

\begin{enumerate}
	\item main.c --- главный файл программы, содержащий функцию \verb|main()|, в теле которой вызываются: 
	
	\verb|fn_checkStartDir()| --- для получения стартовой директории синхронизации, либо создание таковой, если её нет; 
	
	\verb|fn_connetion()| --- для выполнения соединения с клиентом и последующей синхронизации;
	\item funcRecvRespList.c --- файл, содержащий реализации функций для \verb|t_listsRecResp| такие как: 
	
	\verb|static char	*fn_strdup(const char *str)| --- функция создает дубликат строки \verb|(str)| с условием выделения памяти. Возвращает указатель на новую строке, либо \verb|NULL| в случае неудачи;
	
	\verb|static t_listRec	*fn_getLast(t_listRec *head)| --- функция для получения последнего экземпляра \verb|t_listRec| в списке \verb|(head)|.Возвращает указатель на последний \verb|t_listRec|, если существует \verb|head|, иначе \verb|NULL|;
	
	\verb|static void	fn_delElem(t_listRec **head, t_listRec *delElem)| --- функция для удаления элемента \verb|(delElem)| в списке \verb|(head)|;
	
	\verb|void	fn_initListRecResp(t_listsRecResp *env)| --- функция для инициализации структуры \verb|t_listsRecResp|;
	
	\verb|void	fn_removeListsRec(t_listsRecResp *env)| --- функция для очистки стркутуры \verb|t_listsRecResp|;
	
	\verb|void	fn_pushBackRec(t_listRec **head, char *date, char *time)| ---  функция для создания нового экземпляра \verb|t_listRec| в конец списка \verb|(head)| и заполнения его полей \verb|date, time|. В случае ошибки выделения памяти под новый элемент вызывается ошибка и программа завершается;
	
	\item  timingModes.c --- файл, содержащий внутри себя функции для заполнения структуры \verb|s_listsRecResp| на основе выбранного режима синхронизации и полученного .c\_files.  файла.
	
	Функции:
	
	\verb|static void		fn_initList(t_fileConversion *env)| --- инициализация структуры \verb|t_fileConversion|;
	
	\verb|static t_list	*fn_getLast(t_list *head)| --- функция для получения последнего экзмепляра \verb|t_list| в списке \verb|(head)|. Возвращает указатель на последний \verb|t_list|, если существует \verb|head|, иначе \verb|NULL|;
	
	\verb|static void		fn_delElem(t_list **head, t_list *delElem)| --- функция для удаления элемента \verb|(delElem)| в списке \verb|(head)|;
	
	\verb|static void		fn_pushBack(t_list **head, char *date)| --- функция для создания нового экземпляра \verb|t_list| в конец списка \verb|(head)| и заполнения его полей \verb|date, time|. В случае ошибки выделения памяти под новый элемент вызывается ошибка и программа завершается;
	
	\verb|static void		fn_removeLists(t_fileConversion *env)| --- функция для очистки структуры \verb|t_fileConversion|;
	
	\verb|static void		fn_strConversion(t_list **head, const char *src)| --- функция для заполнения листа \verb|(head)| данными из файла \verb|(src)|;
	
	\verb|static void		fn_c2s(t_listsRecResp *recv)| --- функция заполняет поля структуры \verb|(recv)| согласно типу синхронизации, однонаправленная синхронизация данных с клиента на сервер;
	
	\verb|static void		fn_s2c(t_listsRecResp *recv)| --- функция заполняет поля структуры \verb|(recv)| согласно типу синхронизации, однонаправленная синхронизация данных с сервера на клиент; 
	
	\verb|static void		fn_bilateral(t_listsRecResp *recv)| --- функция заполняет поля структуры \verb|(recv)| согласно типу синхронизации, двунаправленная синхронизация данных;
	
	\verb|void			fn_timingModes(t_listsRecResp *recLst, char *s)| --- функция осуществляет заполнение структуры \verb|(recLst)| в соответствии с выбранным на клиенте типом синхронизации \verb|(s)|;
	
	\item serv.c --- файл содержащий реализацию подключения и синхронизации данных.
	
	Функции:
	
	\verb|static void	fn_initServerCTX(t_info *inf)| --- функция для инициализации контекста SSL;
	
	\verb|static void	fn_loadCertificates(t_info *inf, char *CertFile,|
	\verb|char *KeyFile, char *RootFile)| --- функция для загрузки и настройки проверки верификации по сертификатам;
	
	\verb|static void	fn_printWlanIP(void)| --- функция печатающая сетевой интерфейс и IP адрес устройства;
	
	\verb|static void	fn_openListener(t_info *inf)| --- функция инициализирующая сокет и прослушивание порта;
	
	\verb|static void	fn_GetDirPhone(t_info *inf)| --- функция для перехода (создания, если не было) в директорию синхронизации;
	
	\verb|static void	fn_receive_c_file(t_info *inf)| --- функция для получения файла .c\_files с клиента;
	
	\verb|static void	fn_receivingFiles(t_listRec *curr, t_info *inf)| --- функция для получения файла с клиента на сервер;
	
	\verb|static void	fn_sendingFiles(t_listRec *curr, t_info *inf)| --- функция для отправки файла с сервера на клиент;
	
	\verb|static void	fn_receiveDir(t_listRec *curr, t_info *inf, char* c)| --- функция для получения директории с клиента на сервер;
	
	\verb|static void	fn_sendDir(t_listRec *curr, t_info *inf, char* c)| --- функция для отправки директории с сервера на клиент;
	
	\verb|static void	fn_confilctFile(t_listRec *curr, t_info *inf)| --- функция для отправки и вывода информации о конфликтующих файлах;
	
	\verb|static void	fn_solver(char *c, t_info *inf)| --- функция для выполнения синхронизации;
	
	\verb|void	fn_connetion(t_info *inf)| --- функция для выполнения соединения с клиентом и последующей синхронизации;
\end{enumerate}
В первом подкаталоге --- utils --- располагаются файлы с реализациями общих функций, которые используются повсеместно.

Рассмотрим содержимое каталога:
\begin{enumerate}
	\item split.c --- файл для реализации функции разделения строки на подстроки по сепаратору.
	
	Функции:
	
	\verb|static char	**fn_clear(char **tab)| --- функция для очистки указателя на указатель (массив строк) в случае ошибки выделения памяти. Пробрасывает \verb|NULL| в вызываемую функцию;
	
	\verb|static size_t	fn_strlen2sep(const char *str, char sep)| --- функция для подсчета символов в строке \verb|(str)| до следующего разделителя \verb|(sep)|. Возвращает количество символов;
	
	\verb|static size_t	fn_count_words(const char *str, char sep)| --- Функция для подсчета ``слов'' в строке \verb|(str)| с условием разделения по сепаратору (sep); Возвращает количество ``слов'';
	
	\verb|char	**fn_split(char *s, char c)| --- функция разбивает строку \verb|(s)| по сепаратору \verb|(c)| и возвращает указатель на указатель (массив строк), оканчивающийся \verb|NULL|;
	
	\item listOfFiles.c --- файл содержит единственную функцию:\\\verb|void	fn_writeListDir(void)|,  которая создает временный файл .s\_file содержащий перечень файлов и директорий находящихся в текущем рабочем каталоге в алфавитном порядке.
	
	\item checkStartDir.c --- файл содержит функции для проверки наличия в домашнем каталоге директории для синхронизации ``CourseWorkProject''.
	
	Функции: 
	
	\verb|static char	*fn_strjoin(char *s1, char *s2)| --- функция для склейки двух строк \verb|(s1, s2)|. Возвращает указатель на новую строку в случае успеха, иначе \verb|NULL|.
	
	\verb|static char	*fn_parsHome(char **env)| --- функция для получения домашней директории путем парсинга переменного окружения \verb|env|. Возвращает строку, если такая найдена, иначе программа завершается с выводом ошибки.
	
	\verb|void	fn_checkStartDir(t_info *inf)| --- функция для проверки существования каталога синхронизации в домашней директории. Если директория не существует, то пользователю предлагается создать её. Если в домашней директории существует одноименный файл, не являющийся директорий, то выводится ошибка и программа завершается. Иначе происходит модификация \verb|inf->s_dir|: склеивается с ``\~{}/CourseWorkProject''. Возвращает строку, если такая найдена, иначе программа завершается с выводом ошибки;
	
	\item  modification\_time.c --- файл содержит единственную функцию: 
	
	\verb|void	fn_setTimes(char *name, char *times)|, которая устанавливает на файл или каталог время модификации. Входные параметры: \verb|name| -- имя файла или каталога, на который будет установлено время; \verb|times| -- время, которое будет установлено в строковом представлении; формат строки --- YearMonthDayHourMinuteSecond.;
	
	\item utils\_0.c --- содержит такие функции, как:
	
	\verb|void	fn_cleanDict(char **dict)| --- функция для очистки указателя на указатель (массив строк);
	
	\verb|char	*fn_strnstr(const char *haystack, const char *needle, size_t len)| --- функция для поиска подстроки \verb|(needle)| в строке \verb|(haystack)| до \verb|len| символов. Возвращает указатель на первое вхождение, либо \verb|NULL|, если таковое не найдено.
	
	\verb|int	fn_existDir(char *path)| --- функция для проверки существования директории \verb|(path)|. Возвращает \verb|0| в случае успеха, иначе \verb|-1|.
	
	\verb|\item getbrekdown.c| --- файл в котором реализована разбивка строки формата ``utils 19970221153550 DIR'' на подстроки вне зависимости от наличия isspace символов в названии файла.
	
	Функции:
	
	\verb|static char	*fn_strrchr(const char *string, int c)| --- функция для поиска последнего вхождения символа в строке, если символ найден, то возвращается указатель на место, где он находится, иначе \verb|NULL|;
	
	\verb|static int	fn_cnt_word(char *s)| --- функция, которая подсчитывает количество слов в исходной строке (может быть либо 3, либо 2) и возвращает их количество;
	
	\verb|static int fn_len_name(char *s)| --- функция для расчета длины имени файла, возвращает целочисленное значение отличное от нуля в случае успеха, иначе нуль.
	
	\verb|char	**fn_getBreakdown(char *s)| --- функция, которая реализует разбивку на подстроки в зависимости от количества параметров (2 или 3), допуская isspace символы в названии файла.
\end{enumerate}
В другом подкаталоге находятся файлы для реализации функции get\_next\_line:
\begin{enumerate}
	\item get\_next\_line.c --- файл содержит функции для реализации получения подстроки до символа \textbackslash{n};
	
	\verb|static char	*fn_strjoin(char *s1, char *s2)| --- функция для склейки строки \verb|s1| со строкой \verb|s2|, в случае успеха возвращается новая строка, иначе \verb|NULL|;
	
	\verb|static char	*fn_read_file(int fd, char *balance_line)| --- функция считывания строки  из файлового дескриптора до того момента, пока в считанном фрагменте не встретится \textbackslash{n}, либо \textbackslash{0};
	
	\verb|static char	*fn_get2n(char *balance_line)| --- функция подстроки до \textbackslash{n};
	
	\verb|static char	*fn_get_nbalance(char *balance_line)| --- функция получения остатка от строки, после \textbackslash{n}, чтобы при следующем вызове не потерять остаток.
	
	\item get\_next\_line\_utils.c --- файл, содержащий функции, используемые при получении новой строки:
	
	\verb|size_t	fn_strlen(char *s)| --- функция возвращает длину строки;
	
	
	\verb|char	*fn_strchr(char *string, int symbol)| --- функция возвращает указатель на первое вхождение символа в строке, иначе \verb|NULL|;
	
	\verb|char	*fn_substr(char *s, unsigned int start, size_t len)| --- функция для получения подстроки длины \verb|len| начиная с позиции \verb|start|, в случае успеха возвращается указатель на подстроку, иначе \verb|NULL|;
\end{enumerate}

\subsection{Алгоритм синхронизации}
Рассмотрим основной алгоритм синхронизации данных (рис. \ref{dia}), а именно функцию --- \verb|fn_solver()|.
Изначально мы создаем .s\_files с перечнем всех файлов находящихся в синхронизируемой директории на сервере. Для этого используем функцию  \verb|fn_writeListDir()|.

Далее нам необходимо получить .c\_files с информацией о файлах находящихся в синхронизируемой директории на клиенте. Для этого необходимо отправить соответвующий запрос клиенту и начать запись получаемого файла. Всё это реализуется в функции \verb|fn_receive_c_file()|.

Затем нужно инициализировать и заполнить структуру \verb|t_listsRecResp| для этого реализованы функции \verb|fn_initListRecResp()| и \verb|fn_timingModes()|.
Внутри второй функции в зависимости от флага на синхронизацию происходит заполнение полей.

После того как была заполнена структура, мы идет по её полю --- \verb|freadRec|, пока не дойдем до \verb|NULL| элемента, отправляем запрос на получение файлов, находящихся в этом поле, и записываем их на сервер. После записи файлов устанавливаем на них таймкод клиента.

Когда закончилось поле \verb|freadRec| начинаем идти по полю \verb|fwriteRec|, до такого же момента, но уже каждый раз отправляем запрос на отправку файлов клиенту, передаем название файла, сам файл, а затем посылаем запрос на установление времени модификации и отправляем таймкод файла с сервера.

Как только мы дошли до \verb|NULL| в этих полях структуры --- мы синхронизировали все файлы в каталоге, однако там еще остались директории, которые тоже могут потребовать синхронизации. Поэтому пока не встретили \verb|NULL| в поле \verb|dreadRec|, мы пытаемся создать директорию с именем из текущего экземпляра списка, если этого не получилось, то значит данный каталог уже существует. Далее мы переходим в эту директорию и отправляем запрос клиенту, чтобы он тоже перешел в неё же. После чего заново вызываем функцию \verb|fn_solver()|, переходя вниз по стеку вызова. Как только функция \verb|fn_solver()| отработает и программа вернется к предыдущему уровню в стеке, то мы перейдем в родительский каталог и отправим запрос на аналогичные действия клиенту. Далее так как в каталогах создавались файлы, то время модификации на каталогах тоже необходимо синхронизировать, для этого нам необходимо отправить запрос клиенту на модификацию времени, таймкод, а также на сервере вызвать функцию \verb|fn_setTimes()|, для того, чтобы установить время на синхронизированный каталог.

Для синхронизации директории с сервера на клиент нам необходимо проделать похожие действия за исключением первого запроса, он изменится на ``\verb|mkdir && cd|'', остальное будет без изменений.

В итоге после этого шага останется только уведомить обе стороны о файлах-конфликтах, если они имеются. Для этого необходимо пройтись по полю \verb|conflict|, пока текущий элемент не \verb|NULL| и отправить запрос на вывод ошибки клиенту, а затем и название файла.

Можно считать синхронизацию завершенной, остается очистить выделенную память: удалить временные файлы со списками файлов, а также освободить использованную структуру.
\addimghere{pix/Diagramm}{0.9}{Блоксхема алгоритма синхронизации}{dia}
